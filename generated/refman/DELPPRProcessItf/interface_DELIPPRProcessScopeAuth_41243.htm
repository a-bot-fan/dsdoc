<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
 <meta http-equiv="Content-Language" content="en-us"> 
 <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
 <meta name="Generator" content="CppGene v1.1">
 <meta http-equiv="Expires" content="Tue, 04 Dec 1993 21:29:02 GMT">
 <title>DELPPRProcessItf Interface DELIPPRProcessScopeAuth</title>
<link rel="Stylesheet" type="text/css" href="../../../caav5.css">
<link href="../_index/cdg.css" rel="stylesheet" type="text/css"> 
<script type="text/javascript">var PubDirExist = false; var ProDirExist = false; var PrivDirExist = false;</script> 
<script type="text/javascript" src="../_index/cdg.js"></script> 
<script language="Javascript" id="jsLinkjs" type="text/javascript" src="../_index/jslink.js"></script> 
<script language="Javascript" id="jsFwLinkjs" type="text/javascript" src="jsFwLink.js"></script> 
<script language="Javascript" id="jsTreejs" type="text/javascript" src="../_index/jsTree.js"></script>  
</head>
<body>
<div class="menu1" id="menuViewPPP" > 
 	<a href="javascript:writeIndex('IPublic')" name="viewPPP" id="PublicView"  class="ongletPub" > Public View</a> 
 	<a href="javascript:writeIndex('IProtected')" name="viewPPP" id="ProtectedView" class="ongletPro"  > Protected View</a>  
 	<a href="javascript:writeIndex('IPrivate')" name="viewPPP" id="PrivateView" class="ongletPriv" > Private View</a> 
 </div> 
 <div id="indexView" class="menu1">	 
 <a name="multiview" class="onglet" rel="../_index/main.htm" href="../_index/main.htm">All Frameworks</a>   
 <a name="multiview" class="onglet"  rel="../_index/tree.htm" href="../_index/tree.htm">Class Hierarchy</a>   
 <a name="multiview" class="onglet"  rel="../DELPPRProcessItf.htm" href="../DELPPRProcessItf.htm">This Framework</a>
<a name="multiview" class="onglet"  rel="../_index/HomeIdx.htm" href="../_index/HomeIdx.htm">Indexes</a>  
 <a id="multiviewP" class="onglet" href="javascript:openLinkNP(getCurrentObjectName(),getCurrentType(),'0')"  >Previous</a>  
 	<a id="multiviewN" class="onglet" href="javascript:openLinkNP(getCurrentObjectName(),getCurrentType(),'1')"  >Next</a> 
 </div> 
<script type="text/javascript" > 
 	function getCurrentLevel() { 
 return "";	} 
	function getCurrentFw() { 
	return "DELPPRProcessItf";	}
		function getCurrentObjectName() { 
 	return "DELIPPRProcessScopeAuth"; } 
	function getCurrentType() { 
 	return "interface"; }  
 function callInit() { 
 		if (PubDirExist == true || ProDirExist == true || PrivDirExist == true) {  
 			var parent = document.getElementById("indexView"); 
 			if (parent && (ProDirExist == true || PrivDirExist == true) ) { 
 			var elem = document.getElementById("multiviewP"); 
 			if(elem) parent.removeChild(elem); 
 			elem = document.getElementById("multiviewN"); 
 			if(elem) parent.removeChild(elem); }
 			initData(); 
 		} else { 
 			var elem; 
 			var parent = document.getElementById("menuViewPPP"); 
 			if (parent) { 
 				elem = document.getElementById("PublicView"); 
 				parent.removeChild(elem); 
 				elem = document.getElementById("ProtectedView"); 
 				parent.removeChild(elem); 
 				elem = document.getElementById("PrivateView"); 
 				parent.removeChild(elem); 
 			} 
 if (locateObject(getCurrentObjectName(), getCurrentType(), '0')==0) { 
 				elem = document.getElementById("multiviewP"); 
 				if (elem) { elem.removeAttribute("href"); elem.removeAttribute("onclick"); } 
 			} 
 			if (locateObject(getCurrentObjectName(), getCurrentType(), '1')==0) { 
 				elem = document.getElementById("multiviewN"); 
 				if (elem) { elem.removeAttribute("href"); elem.removeAttribute("onclick"); } 
 			} 
 }	 
 	} 
 	window.onload = callInit; 
  </script> 
 
<h1>DELPPRProcessItf Interface DELIPPRProcessScopeAuth</h1>
<script type="text/javascript" > 
 generatedFatherClass('interface_DELIPPRProcessScopeAuth_41243','DELIPPRProcessScopeAuth','0');</script>
<p><b>Usage: an implementation of this interface is supplied and you must use it as is. You should not reimplement it.</b></p>
<hr>
<p>
 interface <b>DELIPPRProcessScopeAuth</b>
</p>
<p>
<b><i> </i></b><br>
</p>
<hr>
 <h2>Method Index</h2> <br>
<dl>
 <dt> o 
    <a href="#CreateScope(CATIPLMNavOccurrence*,CATIPLMNavOccurrence*,CATBoolean&amp;,CATIPLMNavReference*&amp;,CATIPLMNavReference*&amp;,CATLISTP(CATIPLMNavOccurrence)&amp;,CATLISTP(CATIPLMNavOccurrence)&amp;,CATListOfInt&amp;,CATIPLMNavReference*&amp;)"><b>CreateScope</b></a>(CATIPLMNavOccurrence*,CATIPLMNavOccurrence*,CATBoolean&amp;,CATIPLMNavReference*&amp;,CATIPLMNavReference*&amp;,CATLISTP(CATIPLMNavOccurrence)&amp;,CATLISTP(CATIPLMNavOccurrence)&amp;,CATListOfInt&amp;,CATIPLMNavReference*&amp;)
<dd> -------------------------------------------------------------------------------------------------
 DESCRIPTION OF THE METHOD
-------------------------------------------------------------------------------------------------
 Creates a scope link between a process occurrence and a product occurrence.
 <dt> o 
    <a href="#RemoveScope(CATIPLMNavOccurrence*,CATBoolean&amp;,CATIPLMNavReference*&amp;,CATLISTP(CATIPLMNavOccurrence)&amp;,CATLISTP(CATIPLMNavOccurrence)&amp;,CATIPLMNavReference*)"><b>RemoveScope</b></a>(CATIPLMNavOccurrence*,CATBoolean&amp;,CATIPLMNavReference*&amp;,CATLISTP(CATIPLMNavOccurrence)&amp;,CATLISTP(CATIPLMNavOccurrence)&amp;,CATIPLMNavReference*)
<dd>  -------------------------------------------------------------------------------------------------
 DESCRIPTION OF THE METHOD
-------------------------------------------------------------------------------------------------
 Removes the scope link between a product reference <oProductReference> and process occurence
 The deletion of a scope causes the deletion of the implement links between its children processes
 on the products defined inthe scope to remove.
</dl>
<dl>
</dl>
<dl>
</dl>
 <h2>Methods</h2> <br>
<a name="CreateScope"></a><a name="CreateScope(CATIPLMNavOccurrence*,CATIPLMNavOccurrence*,CATBoolean&amp;,CATIPLMNavReference*&amp;,CATIPLMNavReference*&amp;,CATLISTP(CATIPLMNavOccurrence)&amp;,CATLISTP(CATIPLMNavOccurrence)&amp;,CATListOfInt&amp;,CATIPLMNavReference*&amp;)"></a> <dt> o <b>CreateScope</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>CreateScope</b>(<td><script type="text/javascript"> activateLink('CATIPLMNavOccurrence','CATIPLMNavOccurrence*')</script> <td><tt>ipProcessOccurrence</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('CATIPLMNavOccurrence','CATIPLMNavOccurrence*')</script> <td><tt>ipProductOccurrence</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('CATBoolean','CATBoolean&amp;')</script> <td><tt>iCheckModeOnly</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('CATIPLMNavReference','CATIPLMNavReference*&amp;')</script> <td><tt>opProductFromCrossingScope</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('CATIPLMNavReference','CATIPLMNavReference*&amp;')</script> <td><tt>opProcessFromCrossingScope</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('CATLISTP(CATIPLMNavOccurrence)','CATLISTP(CATIPLMNavOccurrence)&amp;')</script> <td><tt>oListOfChildrenProcessFromExistingAssignments</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('CATLISTP(CATIPLMNavOccurrence)','CATLISTP(CATIPLMNavOccurrence)&amp;')</script> <td><tt>oListOfProductfromExistingAssignments</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('CATListOfInt','CATListOfInt&amp;')</script> <td><tt>oListOfReAssignmentStatus</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('CATIPLMNavReference','CATIPLMNavReference*&amp;')</script> <td><tt>ipContextForOutputProductOcc</tt>)<script type="text/javascript"> activateLink('0',' = 0')</script>  </table></dt>
<dl>
  <dd>
-------------------------------------------------------------------------------------------------
 DESCRIPTION OF THE METHOD
-------------------------------------------------------------------------------------------------
 Creates a scope link between a process occurrence and a product occurrence.
 The creation can be blocked because the scope crosses an existing scope.
 This method can be used to check only if the creation is possible and also to create the link
 The different behaviors are managed through <DELMPExecutionMode> enum.
 2 kinds of checking:
    Checking 1 : The scope to create has not to cross an existing scope. 

      Example1:

        Prod1 <------|                    Pcs1
           |         |--scope1---|         |
           |-(Prod2.1)->Prod2    |-------->|-(Pcs2.1)->Pcs2
     
     It is not possible to create a scope between <Product2> and <Process1> because the 
     scope is crossing <scope1>.

      Example2:

         Prod1                             |---->Pcs1
           |                   |--scope2---|       |
           |-(Prod2.1)->Prod2<-|                   |-(Pcs2.1)->Pcs2     
     
     It is not possible to create a scope between <Product1> and <Process2> because the 
     scope is crossing <scope2>.

    Checking 2 : Impact on the existing assignment already made in the existing scopes.

      Example3:
         
       Prod1<------------scope1---------------->Pcs1
         |                                       | 
         |-(Prod2.1)->Prod2                      |-(Pcs2.1)->Pcs2
         |             |                         |             |
         |             |-(Prod3.1)->Prod3        |       |---->|-(Pcs3.1)->Pcs3
         |             |                         |       |                 | 
         |             |-(Prod4.1)->Prod4<--Assignment1--|             |-->|-(Pcs4.1)->Pcs4
         |                                       |                     |
         |-(Prod5.1)->Prod5<--Assignment2--------|---------------------|
         |                                       | 
         |-(Prod6.1)->Prod6<--Assignment3--------|-(Pcs5.1)->Pcs5

       Assignements in <scope1>:
          - <Assignment1> The product occurrence "Prod2.1/Prod3.1/Prod4.1" is assigned to the process instance "Pcs3.1"
          - <Assignment2> The product occurrence "Prod5.1" is assigned to the process instance "Pcs4.1"
          - <Assignment3> The product occurrence "Prod6.1" is assigned to the process instance "Pcs5.1"
  
       Imagine we create a <scope2> between "Prod2" ref and "Pcs2" ref
          The creation of the scope causes:

       Prod1<------------scope1---------------->Pcs1
         |                                       | 
         |-(Prod2.1)->Prod2<--------scope2------>|-(Pcs2.1)->Pcs2
         |             |                         |             |
         |             |-(Prod3.1)->Prod3        |       |---->|-(Pcs3.1)->Pcs3
         |             |                         |       |                 | 
         |             |-(Prod4.1)->Prod4<--Assignment1(MODIFIED)      |-->|-(Pcs4.1)->Pcs4
         |                                                             |
         |-(Prod5.1)->Prod5<--Assignment2(REMOVED)---------------------|
         |                                       | 
         |-(Prod6.1)->Prod6<-Assignment3(KEPT)---|-(Pcs5.1)->Pcs5

                a/ The relimitation of the <Assignment1> in the product side. 
                   The product occurrence "Prod3.1/Prod4.1" is assigned to the process instance "Pcs3.1"
                b/ The deletion of <Assignment2> because "Pcs4" can not longer implement "Prod5".
                c/ <Assignment3> is kept.

-------------------------------------------------------------------------------------------------
 DESCRIPTION OF THE INPUT AND OUTPUT
-------------------------------------------------------------------------------------------------
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> ipProcessOccurrence</tt>
   <dd> [in]   The process occurrence

 </dd>
    <dt><tt> ipProductOccurrence</tt>
   <dd> [in]   The product occurrence

 </dd>
    <dt><tt> iCheckModeOnly</tt>
   <dd> [in]    1/ iCheckModeOnly = TRUE			: This is CHECK_ONLY execution mode where we perform only the checking steps.
    2/ iCheckModeOnly = FALSE			: This is CHECK_AND_PERFORM execution mode where check and perform the creation 
											of the scope and reassigment of children process if needed

 </dd>
    <dt><tt> opProductFromCrossingScope</tt>
   <dd> [out]   Returns a product reference only when the creation of the new scope is not possible 
   because this one is crossing an existing scope.

 </dd>
    <dt><tt> opProcessFromCrossingScope</tt>
   <dd> [out]   Returns a process reference only when the creation of the new scope is not possible 
   because this one is crossing an existing scope.

 </dd>
    <dt><tt> oListOfChildrenProcessFromExistingAssignments</tt>
   <dd> [out]   List of the direct or indirect Process instances that already implement product occurrence(s)
   in an existing scope.

 </dd>
    <dt><tt> oListOfProductfromExistingAssignments</tt>
   <dd> [out]   in <oListOfProcessFromExistingAssignments>
   oListOfProductfromExistingAssignments.Size() = oListOfChildrenProcessFromExistingAssignments.Size()
 WARNING: YOU HAVE TO RELEASE ALL ELEMENTS OF THE LIST

 </dd>
    <dt><tt> oListOfReAssignmentStatus</tt>
   <dd> [out]   This list includes a flag related to each assignment described by the 2 previous lists.
         Flag = 1 : The product will be reassigned in the new scope.
         Flag = 0 : The assigment is removed.
   oListOfReAssignmentStatus.Size() = oListOfProcessFromExistingAssignments.Size()
 
 </dd>
    <dt><tt> ipContextForOutputProductOcc</tt>
   <dd> [in]   Context of the product children occurrence already assigned in an upper scope. Mostly ,the root process  

 </dd>
</dl>
  <dt> <b>Returns:</b> 
  <dd>    <code>S_OK</code> if everything ran ok, otherwise...
 
  <dt> <b>Returns:</b> 
  <dd>     <dl>
   <dt><code>S_OK</code>          <dd>if the method succeeds
   <dt><code>E_FAIL</code>        <dd>if the method fails for any other reason
   </dl>
</dl>
</dl>
<a name="RemoveScope"></a><a name="RemoveScope(CATIPLMNavOccurrence*,CATBoolean&amp;,CATIPLMNavReference*&amp;,CATLISTP(CATIPLMNavOccurrence)&amp;,CATLISTP(CATIPLMNavOccurrence)&amp;,CATIPLMNavReference*)"></a> <dt> o <b>RemoveScope</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>RemoveScope</b>(<td><script type="text/javascript"> activateLink('CATIPLMNavOccurrence','CATIPLMNavOccurrence*')</script> <td><tt>ipiProcessOccurrence</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('CATBoolean','CATBoolean&amp;')</script> <td><tt>iCheckModeOnly</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('CATIPLMNavReference','CATIPLMNavReference*&amp;')</script> <td><tt>opProductReference</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('CATLISTP(CATIPLMNavOccurrence)','CATLISTP(CATIPLMNavOccurrence)&amp;')</script> <td><tt>oListOfChildrenProcessFromExistingAssignments</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('CATLISTP(CATIPLMNavOccurrence)','CATLISTP(CATIPLMNavOccurrence)&amp;')</script> <td><tt>oListOfProductFromExistingAssignments</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('CATIPLMNavReference','CATIPLMNavReference*')</script> <td><tt>ipRootProductOccurrence</tt>)<script type="text/javascript"> activateLink('0',' = 0')</script>  </table></dt>
<dl>
  <dd>
 -------------------------------------------------------------------------------------------------
 DESCRIPTION OF THE METHOD
-------------------------------------------------------------------------------------------------
 Removes the scope link between a product reference <oProductReference> and process occurence
 The deletion of a scope causes the deletion of the implement links between its children processes
 on the products defined inthe scope to remove.

 Example: 

       Prod1<------------scope1---------------->Pcs1
         |                                       | 
         |-(Prod2.1)->Prod2                      |-(Pcs2.1)->Pcs2
         |             |                                       |
         |             |-(Prod3.1)->Prod3                |---->|-(Pcs3.1)->Pcs3
         |             |                                 |                 | 
         |             |-(Prod4.1)->Prod4<--Assignment1--|             |-->|-(Pcs4.1)->Pcs4
         |                                                             |
         |-(Prod5.1)->Prod5<--Assignment2------------------------------|

  This method starts by the deletion of assigment1 and assigment2 before to remove the scope link.
  In check execution mode, this method returns all information to inform the user about the impacts 
  of the deletion.
	
-------------------------------------------------------------------------------------------------
 DESCRIPTION OF THE INPUT AND OUTPUT
-------------------------------------------------------------------------------------------------	
	
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> ipiProcessOccurrence</tt>
   <dd> [in]   The process occurrence

 </dd>
    <dt><tt> iCheckModeOnly</tt>
   <dd> [in]    1/ iCheckModeOnly = TRUE			: This is CHECK_ONLY execution mode where we perform only the checking steps.
    2/ iCheckModeOnly = FALSE			: This is CHECK_AND_PERFORM execution mode where check and perform the creation 
											of the scope and reassigment of children process if needed

 </dd>
    <dt><tt> opProductReference</tt>
   <dd> [out]    This is an OUTPUT to inform the user where the scope was built before the deletion
    We do not need input product because a process can hold only 1 scope.   

 </dd>
    <dt><tt> oListOfChildrenProcessFromExistingAssignments</tt>
   <dd> [out]   This list is linked to the next one. It contains the process children of the scope that already implement
   product contained in the <oListOfProductFromExistingAssignments>. The implement links will be removed 
   before to remove the scope link.  
   This list can contain several time the same process to decribe the case where a process implement several 
   products.

 </dd>
    <dt><tt> oListOfProductFromExistingAssignments</tt>
   <dd> [out]   This list is linked to the previous one. It contains the products occurrences assigned to the process included
   in <oListOfChildrenProcessFromExistingAssignments>.
   oListOfProductFromExistingAssignments.Size() = oListOfChildrenProcessFromExistingAssignments.Size()
 WARNING: YOU HAVE TO RELEASE ALL ELEMENTS OF THE LIST

 </dd>
    <dt><tt> ipRootProductOccurrence</tt>
   <dd> [in]    Context of the product children occurrence (already assigned) that we be unassigned in respect with the scope deletion. Mostly, The root Product

 </dd>
</dl>
  <dt> <b>Returns:</b> 
  <dd>    <code>S_OK</code> if everything ran ok, otherwise...
 
  <dt> <b>Returns:</b> 
  <dd>     <dl>
   <dt><code>S_OK</code>          <dd>if the method succeeds
   <dt><code>E_FAIL</code>        <dd>if the method fails for any other reason
   </dl>

</dl>
</dl>
<hr>
 This object is included in the file: <b>DELIPPRProcessScopeAuth.h</b><br>
If needed, your Imakefile.mk should include the module: <b>DELPPRProcessItf</b>
<hr/><p><i>
Copyright &#169; 1999-2015, Dassault Syst&#232;mes. All rights reserved.
</i></p>
</body>

</html>

